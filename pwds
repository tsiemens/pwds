#!/usr/bin/env python
import argparse
import sys
import os
import json
import re
import base64
from getpass import getpass
try:
    import gnupg
except ImportError:
    print '''gnupg not installed. run:
$ sudo pip install gnupg
pip can usually be found in your package manager under python-pip'''
    quit()

DEFAULT_FILES= [ './pwds.safe', os.path.join( os.environ[ 'HOME' ], 'pwds.safe' ) ]

class PasswordEntry( object ):
    def __init__( self, username=None, email=None, name=None, note=None, password=None ):
        self.username=username
        self.email=email
        self.name=name
        self.note=note
        self.password = password

    def copy( self ):
        return PasswordEntry( username=self.username, email=self.email, name=self.name,
                              note=self.note, password=self.password )

    def __str__( self ):
        return "%s: email:%s, Username:%s, Pass:%s, Note:%s" % \
                ( self.name, self.username, self.email, self.password, self.note )

    def matches( self, pattern, properties=None ):
        if properties == None or len( properties ) == 0:
            properties = [ 'username', 'email', 'name', 'note' ]

        for p in properties:
            if hasattr( self, p ):
                attr = getattr( self, p )
                attr = attr if attr is not None else ''
                if re.search( pattern, attr ):
                    return True
            else:
                print 'No attribute %s' % p
                quit()
        return False

def decodeEntry( obj ):
    return PasswordEntry( username=obj['username'], email=obj['email'],
                          name=obj['name'], note=obj['note'], password=obj['password'] )

class EntryEncoder( json.JSONEncoder ):
    def default( self, obj ):
        return { 'username': obj.username,
                 'email': obj.email,
                 'name': obj.name,
                 'note': obj.note,
                 'password': obj.password }

def decrypt( password, safe ):
    gpg = gnupg.GPG( options=[ 'armor', 'batch' ] )
    with open( safe, 'rb' ) as safef:
        result = gpg.decrypt_file( safef, passphrase=password, always_trust=True )
        return result.data if result.ok else None

def encrypt( password, text, safe ):
    gpg = gnupg.GPG( options=[ 'batch' ] )
    gpg.encrypt( text, encrypt=False, armor=True, symmetric=True, passphrase=password, output=safe )

def promptForPassword( prompt="Enter password: " ):
        return getpass( prompt=prompt )

def getSafeDataAndPass( safeFilename ):
    if os.path.isfile( safeFilename ):
        password = promptForPassword( prompt="Enter password for %s: " % safeFilename )
        return decrypt( password, safeFilename ), password
    else:
        while True:
            password = promptForPassword( prompt="Enter new password for %s: " % safeFilename )
            confPass = promptForPassword( prompt="Confirm password: " )
            if password == confPass:
                return '', password
            else:
                print 'Passwords did not match!'

def loadPasswordEntriesAndSafePass( safeFilename ):
    data, password = getSafeDataAndPass( safeFilename )
    if data is None or data == '':
        writePasswords( [], safeFilename, password )
        return [], password
    else:
        try:
            passes = json.loads( data )
            return [ decodeEntry( o ) for o in passes ], password
        except IOError as e:
            return [], password
        except ValueError:
            print( 'The dafe data could not be parsed. '
                   'Use the dump command to recover the contents.' )
            quit()

def writePasswords( passwordEntries, safeFile, password ):
    encrypt( password, json.dumps( passwordEntries, cls=EntryEncoder ), safeFile )

class PasswordManager( object ):

    def __init__( self, passwords ):
        self.passwords = passwords

    def add( self, username=None, email=None, name=None, note=None ):
        """ Adds a new password. Returns True if successful """
        password = promptForPassword( prompt='Enter password for %s: ' % name )
        newpass = PasswordEntry( username=username, email=email, name=name,
                                 note=note, password=password )
        self.passwords.append( newpass )
        return True

    def getPasswords( self, index=None, pattern=None, searchProps=None, sortProp=None ):
        if index is not None:
            if index >= 0 and index < len( self.passwords ):
                return [ ( index, self.passwords[ index ] ) ]
            else:
                print "No password with index %d" % index
        else:
            passes = [ ( i, self.passwords[ i ] ) for i in range( len( self.passwords ) ) \
                       if pattern is None or self.passwords[ i ].matches( pattern,
                                                                          properties=searchProps ) ]
            if sortProp is not None and len( passes ) > 0:
                if hasattr( passes[ 0 ][ 1 ], sortProp ):
                    passes.sort( key=lambda p: getattr( p[ 1 ], sortProp ) )
                else:
                    print 'No attribute %s' % sortProp
                    quit()
            return passes

    def update( self, indexedEntryTuples, username=None, email=None, name=None,
            note=None, updatePassword=False ):
        """ Updates the passwords. Returns True if successful """
        print "Updating %d entries..." % len( indexedEntryTuples )
        print "Before:"
        self.prettyPrintEntries( indexedEntryTuples )

        password = None
        if updatePassword:
            password = promptForPassword( prompt="Enter new password: " )

        copy = []
        for i, e in indexedEntryTuples:
            ecopy = e.copy()
            ecopy.name = ecopy.name if name == None else name
            ecopy.username = ecopy.username if username == None else username
            ecopy.email = ecopy.email if email == None else email
            ecopy.note = ecopy.note if note == None else note
            ecopy.password = ecopy.password if password == None else password
            copy.append( ( i, ecopy ) )

        print "\nAfter:"
        self.prettyPrintEntries( copy )

        if promptYesNo( "Are these changes ok?" ):
            for orig, changed in zip( indexedEntryTuples, copy ):
                self.passwords[ orig[ 0 ] ] = changed[ 1 ]
            return True
        else:
            return False

    def prettyPrintEntries( self, indexEntryTuples ):
        fmt = '%-3s %-15s %-15s %-25s %-15s %-15s'
        header = fmt % ( '', 'name', 'username', 'email', 'password', 'note' )
        print header
        print '-' * len( header )
        for i, e in indexEntryTuples:
            print fmt % ( str( i ), e.name, e.username, e.email, e.password,
                          e.note.replace( '\n', '\n' + ' ' * ( len( header ) - 15 ) ) \
                                  if e.note is not None else None )

def promptYesNo( question ):
    while True:
        reply = str( raw_input( question + ' [y/n]: ' ) ).lower().strip()
        if reply[ 0 ] == 'y':
            return True
        if reply[ 0 ] == 'n':
            return False

def getFilename( filename ):
    if filename != None:
        return filename

    for f in DEFAULT_FILES:
        if os.path.isfile( f ):
            return f

    return DEFAULT_FILES[ 0 ]

def genKey( length ):
    """ Creates a random password """
    return base64.b64encode( os.urandom( 100 ) )[ :length ]

def addEditParserArgs( parser ):
    parser.add_argument( '--username', '-u', type=str,
                         help='Provide a username' )
    parser.add_argument( '--email', '-e', type=str,
                         help='Provide an account email' )
    parser.add_argument( '--name', '-n', type=str,
                         help='Provide an service/platform name' )
    parser.add_argument( '--note', type=str,
                         help='Provide a note such as Q/As' )
    parser.add_argument( '--password', '-p', action='store_true',
                         help='For update, change the password' )
    parser.add_argument( '--gen-pass', '-g', metavar='LENGTH', type=int, nargs='?', default=-1,
                            help='Generate a password when adding or updating. '
                                 'Default length is 50. Max length is 100' )

def addSelectParserArgs( parser ):
    parser.add_argument( '--index', '-i', type=int,
                         help='Show the entry at this index' )
    parser.add_argument( '--regex', '-r', metavar=('PATTERN', 'PROPERTIES'), type=str, nargs='+',
                         help='A regular expression to search for a password to show or edit.'
                              ' Optional property names can also be provided to search.' )


def cmd_show( args, passMgr ):
    passes = passMgr.getPasswords( index=args.index, sortProp=args.sort,
                                   pattern=args.regex_pattern,
                                   searchProps=args.regex_props )
    passMgr.prettyPrintEntries( passes )
    return False, None

def cmd_add( args, passMgr ):
    success = passMgr.add( name=args.name, username=args.username,
                           email=args.email, note=args.note )
    return success, 'Added password for %s' % args.name

def cmd_update( args, passMgr ):
    if args.index is None and args.regex_pattern is None:
        print "Must provide --index or --regex for update"
        return False, None
    else:
        passes = passMgr.getPasswords( index=args.index,
                                       pattern=args.regex_pattern,
                                       searchProps=args.regex_props )
        success = passMgr.update( passes, name=args.name,
                                  username=args.username,
                                  email=args.email,
                                  note=args.note,
                                  updatePassword=args.password )
        return success, None

def cmd_delete( args, passMgr ):
    return True, None

def cmd_raw_dump( args, passMgr ):
    return False, None

def main():
    argparser = argparse.ArgumentParser( prog='pwds',
            description='Manage passwords in a GPG file.' )

    argparser.add_argument( '--file', '-f', metavar='FILENAME',
                            help='A file to use for storing passwords. Defaults to '
                                 './pwds.safe or ~/.pwds.safe, if they exist, or creates '
                                 './pwds.safe if neither is found.' )

    cmdparser = argparser.add_subparsers( title='command' )

    parser_show = cmdparser.add_parser( 'show' )
    addSelectParserArgs( parser_show )
    parser_show.add_argument( '--sort', '-s', type=str, metavar='PROPERTY',
                              help='Sort show output by property name' )
    parser_show.add_argument( '--raw', action='store_true',
                              help='Equivalent to dump command' )
    parser_show.set_defaults( func=cmd_show )

    parser_add = cmdparser.add_parser( 'add' )
    addEditParserArgs( parser_add )
    parser_add.set_defaults( func=cmd_add )

    parser_update = cmdparser.add_parser( 'update' )
    parser_update.set_defaults( func=cmd_update )

    parser_delete = cmdparser.add_parser( 'delete' )
    parser_delete.set_defaults( func=cmd_delete )

    parser_raw = cmdparser.add_parser( 'dump' )
    parser_raw.set_defaults( func=cmd_raw_dump )

    args = argparser.parse_args()

    safeFile = getFilename( args.file )
    passwords, safePass = loadPasswordEntriesAndSafePass( safeFile )
    passManager = PasswordManager( passwords )

    if hasattr( args, 'regex' ):
        args.regex_pattern = args.regex[ 0 ] if args.regex is not None else None
        args.regex_props = args.regex[ 1: ] if args.regex is not None else None

    shouldWrite, writeMsg = args.func( args, passManager )

    if shouldWrite:
        writePasswords( passManager.passwords, safeFile, safePass )
        if writeMsg:
            print writeMsg

if __name__ == '__main__':
    main()
