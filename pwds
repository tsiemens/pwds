#!/usr/bin/env python
import argparse
import sys
import os
import json
import re
from getpass import getpass

DEFAULT_FILES= [ './pwds.safe', os.path.join( os.environ[ 'HOME' ], 'pwds.safe' ) ]

class PasswordEntry( object ):
    def __init__( self, username=None, email=None, name=None, note=None, password=None ):
        self.username=username
        self.email=email
        self.name=name
        self.note=note
        self.password = password

    def copy( self ):
        return PasswordEntry( username=self.username, email=self.email, name=self.name,
                              note=self.note, password=self.password )

    def __str__( self ):
        return "%s: email:%s, Username:%s, Pass:%s, Note:%s" % \
                ( self.name, self.username, self.email, self.password, self.note )

    def matches( self, pattern, properties=None ):
        if properties == None or len( properties ) == 0:
            properties = [ 'username', 'email', 'name', 'note' ]

        for p in properties:
            if hasattr( self, p ):
                if getattr( self, p ) is not None and re.search( pattern, getattr( self, p ) ):
                    return True
            else:
                print 'No attribute %s' % p
                quit()
        return False

def decodeEntry( obj ):
    return PasswordEntry( username=obj['username'], email=obj['email'],
                          name=obj['name'], note=obj['note'], password=obj['password'] )

class EntryEncoder( json.JSONEncoder ):
    def default( self, obj ):
        return { 'username': obj.username,
                 'email': obj.email,
                 'name': obj.name,
                 'note': obj.note,
                 'password': obj.password }

class PasswordManager( object ):

    def __init__( self, safeFile ):
        self.safeFile = safeFile
        self.passwords = self.loadPasswords()

    def add( self, username=None, email=None, name=None, note=None ):
        password = promptForPassword()
        newpass = PasswordEntry( username=username, email=email, name=name,
                                 note=note, password=password )
        self.passwords.append( newpass )
        self.writePasswords()

    def loadPasswords( self ):
        try:
            with open( self.safeFile, 'r' ) as f:
                passes = json.loads( f.read() )
                return [ decodeEntry( o ) for o in passes ]
        except IOError as e:
            return []

    def writePasswords( self ):
        with open( self.safeFile, 'w' ) as f:
            f.write( json.dumps( self.passwords, cls=EntryEncoder ) )

    def getPasswords( self, index=None, pattern=None, searchProps=None, sortProp=None ):
        if index is not None:
            if index >= 0 and index < len( self.passwords ):
                return [ ( index, self.passwords[ index ] ) ]
            else:
                print "No password with index %d" % index
        else:
            passes = [ ( i, self.passwords[ i ] ) for i in range( len( self.passwords ) ) \
                       if pattern is None or self.passwords[ i ].matches( pattern,
                                                                          properties=searchProps ) ]
            if sortProp is not None and len( passes ) > 0:
                if hasattr( passes[ 0 ][ 1 ], sortProp ):
                    passes.sort( key=lambda p: getattr( p[ 1 ], sortProp ) )
                else:
                    print 'No attribute %s' % sortProp
                    quit()
            return passes

    def update( self, indexedEntryTuples, username=None, email=None, name=None,
            note=None, updatePassword=False ):
        print "Updating %d entries..." % len( indexedEntryTuples )
        print "Before:"
        self.prettyPrintEntries( indexedEntryTuples )

        password = None
        if updatePassword:
            password = promptForPassword( prompt="Enter new password: " )

        copy = []
        for i, e in indexedEntryTuples:
            ecopy = e.copy()
            ecopy.name = ecopy.name if name == None else name
            ecopy.username = ecopy.username if username == None else username
            ecopy.email = ecopy.email if email == None else email
            ecopy.note = ecopy.note if note == None else note
            ecopy.password = ecopy.password if password == None else password
            copy.append( ( i, ecopy ) )

        print "\nAfter:"
        self.prettyPrintEntries( copy )

        if promptYesNo( "Are these changes ok?" ):
            for orig, changed in zip( indexedEntryTuples, copy ):
                self.passwords[ orig[ 0 ] ] = changed[ 1 ]
            self.writePasswords()

    def prettyPrintEntries( self, indexEntryTuples ):
        fmt = '%-3s %-15s %-15s %-25s %-15s %-15s'
        header = fmt % ( '', 'name', 'username', 'email', 'password', 'note' )
        print header
        print '-' * len( header )
        for i, e in indexEntryTuples:
            print fmt % ( str( i ), e.name, e.username, e.email, e.password,
                          e.note.replace( '\n', '\n' + ' ' * ( len( header ) - 15 ) ) \
                                  if e.note is not None else None )

def promptYesNo( question ):
    while True:
        reply = str( raw_input( question + ' [y/n]: ' ) ).lower().strip()
        if reply[ 0 ] == 'y':
            return True
        if reply[ 0 ] == 'n':
            return False

def promptForPassword( prompt="Enter password: " ):
        return getpass( prompt=prompt )

def getFilename( filename ):
    if filename != None:
        return filename

    for f in DEFAULT_FILES:
        if os.path.isfile( f ):
            return f

    return DEFAULT_FILES[ 0 ]

def main():
    argparser = argparse.ArgumentParser( prog='pwds',
            usage='%(prog)s COMMAND [ OPTIONS ]',
            description='Manage passwords in a GPG file.' )
    argparser.add_argument( 'command', metavar='COMMAND', type=str,
                            help='The command to use: [ add | update | show | delete | help ]' )
    argparser.add_argument( '--username', '-u', type=str,
                            help='Provide a username' )
    argparser.add_argument( '--email', '-e', type=str,
                            help='Provide an account email' )
    argparser.add_argument( '--name', '-n', type=str,
                            help='Provide an service/platform name' )
    argparser.add_argument( '--note', type=str,
                            help='Provide a note such as Q/As' )
    argparser.add_argument( '--index', '-i', type=int,
                            help='Provide an service/platform name' )
    argparser.add_argument( '--password', '-p', action='store_true',
                            help='For update, change the password' )
    argparser.add_argument( '--regex', '-r', metavar=('PATTERN', 'PROPERTIES'), type=str, nargs='+',
                            help='A regular expression to search for a password to show or edit.'
                                 ' Optional property names can also be provided to search.' )
    argparser.add_argument( '--sort', '-s', type=str, metavar='PROPERTY',
                            help='Sort show output by property name' )
    argparser.add_argument( '--gen-pass', '-g', metavar='LENGTH', type=int, nargs='?', default=-1,
                            help='Generate a password when adding or updating. '
                                 'Default length is 50. Max length is 100' )
    argparser.add_argument( '--file', '-f', metavar='FILENAME',
                            help='A file to use for storing passwords. Defaults to '
                                 './pwds.safe or ~/.pwds.safe, if they exist, or creates '
                                 './pwds.safe if neither is found.' )

    args = argparser.parse_args()
    safeFile = getFilename( args.file )
    passManager = PasswordManager( safeFile )

    args.regex_pattern = args.regex[ 0 ] if args.regex is not None else None
    args.regex_props = args.regex[ 1: ] if args.regex is not None else None

    if args.command == 'show':
        passes = passManager.getPasswords( index=args.index, sortProp=args.sort,
                                           pattern=args.regex_pattern,
                                           searchProps=args.regex_props )
        passManager.prettyPrintEntries( passes )
    elif args.command == 'add':
        passManager.add( name=args.name, username=args.username, email=args.email, note=args.note )
        print "Added password for %s" % args.name
    elif args.command == 'update':
        if args.index is None and args.regex_pattern is None:
            print "Must provide --index or --regex for update"
        else:
            passes = passManager.getPasswords( index=args.index,
                                               pattern=args.regex_pattern,
                                               searchProps=args.regex_props )
            passManager.update( passes, name=args.name, username=args.username, email=args.email,
                                note=args.note, updatePassword=args.password )
    else:
        print 'Unrecognized command "%s"' % args.command

if __name__ == '__main__':
    main()
